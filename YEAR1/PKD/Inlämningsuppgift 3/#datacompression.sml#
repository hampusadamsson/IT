(*HashArray.hash i
TYPE: int -> 'a HashArray.hash
PRE : i > 0
POST: a hash table with i cells

HashArray.sub (h, s)
TYPE: 'a hash * string -> 'a option
PRE:  none
POST: SOME v where v is the value the string s is mapped to in h
      if such a mapping exists, NONE otherwise

HashArray.update (h, s, v)
TYPE: 'a hash * string * 'a -> unit
PRE:  none
POST: ()
SIDE-EFFECTS: updates h such that s is mapped to v
*)

(* dictionary f
TYPE: string -> 
PRE : 
POST: Skapar en ordbok av f*)

fun dictionary f =
    let
	val dict = HashArray.hash 4049;
	fun dictionary'(f) =
	    while HashArray.sub(dict,i) <> NONE do
		    (
		     )
	    
	    dictionary'(tl f)
    in
    end;




(* compress' fil ordbok
TYPE: char list * int list -> int list
PRE: någoting...
POST: returnerar teckenlistan som en kodsekvens.
*)
	    fun compress' (f,d,ord) =


(* compress f
TYPE: char list -> int list
PRE : f är sökvägen till en fil som finns och läsbar (samt endast innehåller tecken i ordboken d.) (* Skapar vår egen ordbok???*) 
POST: returnerar innhållet i filen f som en kodsekvens (av heltal i en lista) 
*)

fun compress () = 
    let
	val fil = [a, a, a, b, b, b,b, b, b, a, a, b, a, a, b, a];
	val ordbok =  [97, 256, 98, 258, 259, 257, 261];

		
		
    in
	compress'(fil,ordbok,"")
    end;

